<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: First Assignment of the Research Track 2 course (Robotics Engineering / JEMARO, Unige)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">First Assignment of the Research Track 2 course (Robotics Engineering / JEMARO, Unige) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Package explanation</h1>
<p>The package manages the mobile non-holonomic robot with a simple 'go_to_point' behaviour:</p>
<p>*An irregular objective is given (a posture, [x,y,theta]) *The robot situates itself towards the [x,y] destination *Then, at that point, drives directly to that position (changing the direction assuming need); *Having reached the [x,y] objective position the robot turns set up to match the objective theta; *In the event that the client doesn't stop the robot GOTO stage 1, in any case stay still until requested to begin once more, then, at that point, GOTO stage 1;</p>
<p>Since the client demand is here carried out as an activity it tends to be acquired, stoppinng the robot whenever and afterward restarting it while giving another objective.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Content description</h1>
<p>Two nodes are carried out as python scripts</p>
<p><a class="el" href="go__to__point_8py.html" title="Node implementing the go_to_point behavior.">go_to_point.py</a>: the action server dealing with the robot speed control contingent upon the objective goal. user_interface.py: the straightforward order line UI, which sends the request to begin/stop the go_to_point behaviour.</p>
<p>While the last two are C++ based nodes</p>
<p><a class="el" href="position__service_8cpp.html" title="Node responsible for generating a random position (x, y, \theta).">position_service.cpp</a>: the server creating an arbitrary posture [x,y,theta] as a reaction to a request. <a class="el" href="state__machine_8cpp.html" title="Node issuing new goals for the robot.">state_machine.cpp</a>: the FSM dealing with the request of another objective posture while required, sending it as an objective to 'go_to_point' activity server.</p>
<p>At last, the control can be applied to a robot recreated utilizing Coppeliasim (see Requirements), for which two scenes are here introduced</p>
<p>pioneer_scene.ttt: a basic scene with a Pioneer p3dx non-holonomic versatile robot in a vacant environment.</p>
<p>robotnik_scene.ttt: a simple scene scene with a Robotnik Summit XL140701 non-holonomic mobile robot in a vacant environment.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
To Run and compile</h1>
<p>Compilation can be done as always with </p><pre class="fragment">           path/to/ros_ws/$ catkin_make
</pre><p>Two launch files are given</p>
<p>sim.launch: to be utilized in order to launch all the nodes and the Gazebo simulation </p><pre class="fragment">           path/to/ros_ws/$ roslaunch rt2_assignment1 sim.launch
</pre><p>For this situation the Gazebo recreation will naturally begin.</p>
<p>sim_coppelia.launch: to be utilized in order to all the nodes which will gives with the Coppelia simulation. </p><pre class="fragment">           path/to/ros_ws/$ roslaunch rt2_assignment1 sim_coppelia.launch
</pre><p>For this situation CoppeliaSim should be begun independently (make sure to have a case of roscore running prior to sending off the CoppeliaSim executable). The reproduction can be either begun previously or subsequent to sending off then nodes, yet don't attempt to run another recreation when the hubs have been running on a past one (or the framework could wind up in an underlying state differente from the expected to be one, always being unable to arrive at the goal).In different terms, each time simulation is restarted the nodes should be to, and vice-versa (generally).</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Notebook</h1>
<p>A Jupyter Notebook can be found under the notebooks folder. By executing it the robot can be controlled with a graphical UI giving additionally ongoing charts of the robot conduct. More subtleties in the actual journal. To begin the journal execute </p><pre class="fragment">         path/to/ros_ws/src/rt2_assignment1/notebooks$ jupyter notebook --allow-root --ip 0.0.0.0
</pre><p>Then open web browser at localhost:8888 and select the notebook <br  />
</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Execution description</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
StateMachine</h2>
<p>The main decision worth of note likely respects the way that the current robot state can be changed by either the client's feedback (1: begin, - 1: stop) or the action arriving at its objective goal (2: activity finished): in the last option case the condition of the objective goal is recovered, and a check is made on regardless of whether the activity was succesful. On the off chance that it succeeded, it begins again by characterizing another irregular objective point, if not the robot will pause and sit tight for new client inputs.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Documentation</h2>
<p>Next to this README further documentation of all classes and techniques can be found in the doc organizer.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Requirements</h2>
<p>Gazebo is expected to run the first launch file (the scene definition is introduced in this package). Coppeliasim is expected to run the second launch file <a href="http://www.coppeliarobotics.com/downloads.html">http://www.coppeliarobotics.com/downloads.html</a></p>
<h2><a class="anchor" id="autotoc_md9"></a>
Known issues and limitations</h2>
<p>Assuming you take a stab at running both the Gazebo and CoppeliaSim and the last option appears to not answer to the hubs, while the UI results frozen subsequent to having advised the framework to run, attempt to kill the roscore interaction; this may be connected with Gazebo overwriting a few qualities connected with the simulation (most likely reproduction time) and these not being properly "cleaned" whenever Gazebo is shut. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
