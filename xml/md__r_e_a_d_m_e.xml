<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="md__r_e_a_d_m_e" kind="page">
    <compoundname>md_README</compoundname>
    <title>Package explanation</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>The package manages the mobile non-holonomic robot with a simple &apos;<ref refid="namespacego__to__point" kindref="compound">go_to_point</ref>&apos; behaviour:</para>
<para>*An irregular objective is given (a posture, [x,y,theta]) *The robot situates itself towards the [x,y] destination *Then, at that point, drives directly to that position (changing the direction assuming need); *Having reached the [x,y] objective position the robot turns set up to match the objective theta; *In the event that the client doesn&apos;t stop the robot GOTO stage 1, in any case stay still until requested to begin once more, then, at that point, GOTO stage 1;</para>
<para>Since the client demand is here carried out as an action it tends to be acquired, stoppinng the robot whenever and afterward restarting it while giving another objective.</para>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md1">
<title>Content description</title>
<para>Two nodes are carried out as python scripts</para>
<para>go_to_point.py: the action server dealing with the robot speed control contingent upon the objective goal. user_interface.py: the simple command line UI, which sends the request to begin/stop the <ref refid="namespacego__to__point" kindref="compound">go_to_point</ref> behaviour.</para>
<para>While the last two are C++ based nodes</para>
<para><ref refid="position__service_8cpp" kindref="compound">position_service.cpp</ref>: the server creating an arbitrary posture [x,y,theta] as a reaction to a request. <ref refid="state__machine_8cpp" kindref="compound">state_machine.cpp</ref>: the FSM dealing with the request of another objective posture while required, sending it as an objective to &apos;<ref refid="namespacego__to__point" kindref="compound">go_to_point</ref>&apos; action server.</para>
<para>At last, the control can be applied to a robot recreated utilizing Coppeliasim (see Requirements), for which two scenes are here introduced</para>
<para>pioneer_scene.ttt: a basic scene with a Pioneer p3dx non-holonomic versatile robot in a vacant environment.</para>
<para>robotnik_scene.ttt: a simple scene scene with a Robotnik Summit XL140701 non-holonomic mobile robot in a vacant environment.</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md2">
<title>To Run and compile</title>
<para>Compilation can be done as always with <verbatim>           path/to/ros_ws/$ catkin_make
</verbatim></para>
<para>Two launch files are given</para>
<para>sim.launch: to be utilized in order to launch all the nodes and the Gazebo simulation <verbatim>           path/to/ros_ws/$ roslaunch rt2_assignment1 sim.launch
</verbatim></para>
<para>For this situation the Gazebo recreation will naturally begin.</para>
<para>sim_coppelia.launch: to be utilized in order to all the nodes which will gives with the Coppelia simulation. <verbatim>           path/to/ros_ws/$ roslaunch rt2_assignment1 sim_coppelia.launch
</verbatim></para>
<para>For this situation CoppeliaSim should be begun independently (make sure to have a case of roscore running prior to sending off the CoppeliaSim executable). The reproduction can be either begun previously or subsequent to sending off then nodes, yet don&apos;t attempt to run another recreation when the hubs have been running on a past one (or the framework could wind up in an underlying state differente from the expected to be one, always being unable to arrive at the goal).In different terms, each time simulation is restarted the nodes should be to, and vice-versa (generally).</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md3">
<title>Notebook</title>
<para>A Jupyter Notebook can be found under the notebooks folder. By executing it the robot can be controlled with a graphical UI giving additionally ongoing charts of the robot conduct. More subtleties in the actual journal. To begin the journal execute <verbatim>         path/to/ros_ws/src/rt2_assignment1/notebooks$ jupyter notebook --allow-root --ip 0.0.0.0
</verbatim></para>
<para>Then open web browser at localhost:8888 and select the notebook <linebreak/>
</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md4">
<title>Execution description</title>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md5">
<title>StateMachine</title>
<para>The main decision worth of note likely respects the way that the current robot state can be changed by either the client&apos;s feedback (1: begin, - 1: stop) or the action arriving at its objective goal (2: activity finished): in the last option case the condition of the objective goal is recovered, and a check is made on regardless of whether the activity was succesful. On the off chance that it succeeded, it begins again by characterizing another irregular objective point, if not the robot will pause and sit tight for new client inputs.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md6">
<title>Documentation</title>
<para>Next to this README further documentation of all classes and techniques can be found in the doc organizer.</para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md7">
<title>Requirements</title>
<para>Gazebo is expected to run the first launch file (the scene definition is introduced in this package). Coppeliasim is expected to run the second launch file <ulink url="http://www.coppeliarobotics.com/downloads.html">http://www.coppeliarobotics.com/downloads.html</ulink></para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md8">
<title>Known issues and limitations</title>
<para>Assuming you take a stab at running both the Gazebo and CoppeliaSim and the last option appears to not answer to the hubs, while the UI results frozen subsequent to having advised the framework to run, attempt to kill the roscore interaction; this may be connected with Gazebo overwriting a few qualities connected with the simulation (most likely reproduction time) and these not being properly &quot;cleaned&quot; whenever Gazebo is shut. </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
